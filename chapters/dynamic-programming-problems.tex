\section{Dynamic Programming Problems}

Dynamic programming is...

Consider the problem of calculating the Fibonacci sequence. The Fibonacci sequence is the sequence $0,1,1,2,3,5,8,13,21,34,55,89,...$ where each value (other than the initial $0,1$) is the sum of the previous two (so $89 = 55 + 34$, $55 = 34 + 21$, $34 = 21 + 13$, and so on). This is a pretty intuitive example of recursion, like in:

\inputcpp{code/dp/fib_recursive.cpp}

Unfortunately, this results in a lot of repeated work. A call to \mintinline{cpp}{fibonacci(10)} will call \mintinline{cpp}{fibonacci(9)} and \mintinline{cpp}{fibonacci(8)}, where \mintinline{cpp}{fibonacci(9)} will also call \mintinline{cpp}{fibonacci(8)}, \mintinline{cpp}{fibonacci(7)} ends up getting called 3 times, \mintinline{cpp}{fibonacci(6)} gets called 5 times, and so on until \mintinline{cpp}{fibonacci(1)} ultimately gets called 56 times. There is a huge amount of work being done with these recursive calls \textit{that we already obtained the result from earlier}.

Dynamic programming fixes this by storing the results of these recursive subcalls in a process called memoization.

\inputcpp{code/dp/fib_dp_td.cpp}

That is called "top down" dynamic programming because we still make recursive calls, but if we've already gotten the result from one of our recursive calls we'll store it for any times it appears later.

The alternative is "bottom up" dynamic programming where we start with the smallest cases and gradually work our way up:

\inputcpp{code/dp/fib_dp_bu.cpp}

Here, we don't make any recursive calls at all -- a call of \mintinline{cpp}{fibonacci(10)} will not result in recalculating earlier values in the sequence repeatedly.

You may note that we can store this permanently, by precalculating entirely:

\inputcpp{code/dp/fib_precalc.cpp}

Where we call \mintinline{cpp}{genFibonacci()} at the start of the program, and then obtain results from \mintinline{cpp}{fibonacci(n)} or even directly with \mintinline{cpp}{f[n]}.

This works in this specific instance because our stored results are always the same: we always begin with {0,1} and always add the previous two terms. If this might change, whether it be by having different starting numbers or a different number of previous terms (or even coefficients on those terms), we couldn't precalculate beforehand.

\subsection{Coin Change}

Something of interest is that we can also use dynamic programming to efficiently count the number of valid solutions for a given problem.

An example of this will be in the coin change problem. Let's say we have a target value $100$ and a list of elements $10,25,90$, and we want to count how many different ways we can make change from $100$ evenly using the elements of our array. In this variant, we have an infinite amount of each element (so that we can reuse the same values repeatedly). It should be pretty easy to determine the valid solutions, $\{10,90\}$, $\{10,10,10,10,10,25,25\}$, $\{25,25,25,25\}$, and $\{10,10,10,10,10,10,10,10,10,10\}$. Therefore, the count of different ways to make change from $100$ evenly is $4$.

What do we do when our list of valid coins is $\{1,2,3,4,5,6,7,8,9,10,17,25,90\}$? It should be clear that this would be difficult to do naively -- $100$ $1$s is a valid solution, $98$ $1$s and a $2$ is a valid solution, $97$ $1$s and a $3$ is a valid solution, $96$ $1$s and a $4$ or $2$ $2$s are both valid solutions, something like $90$ $1$s and any of $\{10\},\{8,2\},\{7,3\},\{6,4\},\{5,5\},\{6,2,2\},\{5,3,2\},\{4,4,2\},\{4,2,2,2\},\{3,3,2,2\},\{2,2,2,2,2\}$ are all valid solutions. It is far too difficult to simply look at the problem and be able to accurately determine the proper number of valid solutions (in this case, that number is $9505074$).

\inputcpp{code/dp/coinchange.cpp}

\subsection{Longest Common Subsequence}

The Longest Common Subsequence problem (commonly called the LCS problem) is one where you're given two strings (or some other array of data) and, as the name suggests, you have to find the longest subsequence they have in common.

Recall that subsequences refer to a sequence with some elements deleted from the original (including no elements or all elements), so that there is (potentially) less elements but they are all from the original sequence and keep the original ordering. For example, with the string "abcdef", some valid subsequences would be "abc" or "ace", or even the original string "abcdef" or an empty string "".

A subsequence in common, therefore, would be any subsequence that exists in two different sequences at once. Given two strings "abcdef" and "defghi", they might contain the common subsequences \{"", "d", "e", "f", "de", "ef", "def"\}. As another example, the common subsequences of "abcdef" and "aceg" would be \{"", "a", "c", "e", "ac", "ce", "ace"\}. It should be clear what the longest common subsequence is with these examples, "def" and "ace" respectively.

A potential problem that we may have to deal with is that the first possible subsequence we can take isn't necessarily the best one. In the above examples, you might notice that simply adding all letters they have in common would give you the right answers in those testcases. This is not true for all possible strings, for example with "abcde" and "abdbce" if we took a greedy approach we would likely find "abd" when the longest common subsequence is actually "abce".


\subsection{Longest Increasing Subsequence}
