\section{Foundational Algorithms}

There are a few algorithms that should be covered and discussed before going into much further explorations.

\subsection{Sorting}

Sorting is likely the most fundamental algorithm you will use in competitive programming. It appears in many problems, to the point where problems that just require sorting to solve them are usually considered relatively easy. More often you'll see sorting be involved as a necessary component to more difficult problems. In many cases, sorting is required in order to perform efficient algorithms (as we will see soon, sorting is required to perform a \textbf{binary search} which is generally much faster than a \textbf{sequential search}).

The goal of a sorting algorithm is simple, to transform an array of data to be sorted. A basic example would be given $1,5,3,4,2$ as an array, sorting would yield $1,2,3,4,5$. Or, $1000,50,100,1$ becomes $1,50,100,1000$.

\subsubsection{Sorting Concepts}

A \textbf{sorted} array refers to one where elements are ordered according to some criteria. In practice, this is usually in ascending order (so that each element is larger than the previous) and less occasionally in descending order (where each element is smaller than the previous, which sometimes is called "sorted in reverse").

In comparison, an \textbf{unsorted} array refers to one where this criteria is not met.

There are two main types of sorting algorithms: \textbf{comparison sorts} and \textbf{integer sorts}. The comparison variety relies on exactly what it says, comparisons.

What determines ascending or descending order can depend on what specifically is being sorted. For integers it's easy, one is clearly larger or smaller (or equal) to another. Same with floating point numbers. For strings, it's usually lexicographical order (alphabetical order). For more complex types it's not necessarily clear. To sort an array of queues stacks, it's less obvious what you should do, and it may depend entirely on your use case. In some problems you'll even find yourself with a \mintinline{cpp}{pair<int,int>} where you want to sort by the first integer at one part of your program, and then later sort by the second integer. In a comparison sort, you will have some \textbf{comparison function} that determines how to compare different elements with each other.

An integer sort on the other hand doesn't make use of any comparison function, and instead relies on properties about integers themselves. As a result, it doesn't work on arbitrary types, and you can't make it have its own sorting criteria by changing how it should compare elements. Generally, these sorting algorithms are much more specialized. That said a few integer sorting algorithms can offer very good runtime complexity, and depending on the data can offer significant speedups over any comparison sort alternative.

Another classification for sorting algorithms is whether they're \textbf{stable} or not. A stable sorting algorithm will ensure that different elements that compare equally to eachother (for custom classes with their own comparators for example) will have keep the relative order that they appeared in originally. For example, with an array of pairs $\{1,1\}, \{2,2\}, \{1,3\}, \{2,4\}, \{1,5\}$ where the comparison function only compares the first element of each pair, a stably sorted array would look like $\{1,1\}, \{1,3\}, \{1,5\}, \{2,2\}, \{2,4\}$.

In contrast, an \textbf{unstable} algorithm makes no guarantees. It could pretty easily still end up sorted the exact same as a stable sorting algorithm, but it isn't necessarily going to.

If every element of the array is unique, the difference between stable and unstable doesn't matter. If there are duplicate elements in the array, but you don't have any other data associated with them (two duplicate elements will be identical to eachother) then it doesn't matter either. It also wouldn't matter if duplicate elements with different data exist, but you don't really care what order they appear in as long as they're sorted relative to other elements. It's only in the (relatively narrow) circumstance that all these properties hold and the original order of duplicate elements is relevant that the difference between stable and unstable matters.

\subsubsection{Insertion Sort}

\subsubsection{Quicksort}

\subsubsection{Mergesort}

\subsubsection{Counting Sort}

Consider the case where you have $10^9$ 1-digit numbers that you want to sort. It is certainly possible to perform a comparison-based sort that will run in $O(n log n)$, there is actually an integer sort that's perfectly suited for this sort of problem that runs in $O(n)$.

\textbf{Counting sort} is based around having an array where each element is the number of times that index appeared in the original unsorted list. For example, with the array $0,5,2,2,2,1,5,9$ we would have the counts $1,1,3,0,0,2,0,0,0,1$ because 0 appears once, 1 appears once, 2 appears three times, 4 never appears, and so on. Generating this is a simple process -- simply iterate through the unsorted list and increase the necessary count by 1 for every element. This takes $O(n)$.

The next step is to create a new sorted array, once we know the counts of each value. This time we iterate through our counts and insert them into our new array. When a value was counted multiple times, we insert it that many times. The result of this will be an array containing $0,1,2,2,2,5,5,9$, the sorted version of the original array.

\subsection{Searching}

Often, you need to check whether an element exists within an array. Other times, you have to find the index of that element. In any case, given an array (or other list of elements), searching for an element is a common task. Like sorting, this is often fairly simple when done on its own, and more often than not it's a subtask of a larger problem or a part of a larger algorithm entirely.

There are various algorithms for searching for an element within an array.

\subsubsection{Sequential Search}

Sequential search is the simplest form of searching for an element within an array. It consists of a simple for-loop that checks each individual element 

It's useful because it doesn't rely on the array being sorted or anything like that. While it is often quite slow, it can be useful when runtime is not a concern.

\subsubsection{Binary Search}

Binary search is an extremely common search algorithm that uses the structure of a sorted array to offer great speedups.

\subsubsection{Unimodal Searches}

Less commonly, you may want to search the outputs of a function rather than an array. There are some search algorithms designed to search for maximums or minimums in a unimodal function (a function that has only one unique maximum or minimum).

\textbf{Ternary Search} is...

\textbf{Golden Section Search} is...