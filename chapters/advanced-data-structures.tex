\section{Advanced Data Structures}

"Advanced" is possibly a misnomer. Some of these data structures aren't very complicated, in either their implementation or their usage. We call them advanced here because they relate to much more specific and particular applications. Things like arrays or sets are necessary to solve many basic problems -- while things like range-based structures may be necessary to efficiently implement an algorithm or solution, the problems they appear in are never as simple.

\subsection{Range-based Structures}
\subsubsection{Prefix Sum Arrays}

Prefix sums are not a particularly complicated data structure. However, they are useful as the most basic form of range-based data structures. As the name suggests, they deal with sums of integers.

If we are given an array of integers, we can generate a prefix sum array by making each element be the cumulative sum of all elements before it in the original array. For example, given an array $arr = \{1,2,3,5,10,3,2,5\}$, our prefix sum is $ps = \{1,3,6,11,21,24,26,31\}$ because each $ps_i$ is equal to $arr_0 + ... + arr_i$.

Generating the prefix sum is a simple process...

Normally, the prefix sum gives us the sum of the array from $[0,i)$. We can obtain the sum of an arbitrary subarray $[l,r)$ by obtaining $[0,r)$ and subtracting $[0,l)$. 

While for some problems prefix sums are sufficient (construction in $O(n)$ and queries in $O(1)$), they aren't able to be updated efficiently (you would have to recalculate all sums after the element you're updating, which is $O(n)$).

\subsubsection{Sparse Table}
\subsubsection{Fenwick Tree / Binary Indexed Tree}

Fenwick Trees, also commonly known as Binary Indexed Trees (which is also commonly abbreviated to BITs) is a structure that allows calculates the prefix sum that can be queried in $O(log n)$ and allows for updates in $O(log n)$ as well, compared to the prefix sum array that allows $O(1)$ queries but $O(n)$ updates.

\subsubsection{Segment Tree}

Segment Trees are conceptually similar to Fenwick Trees, in that they support range queries in $O(log n)$ and updates in $O(log n)$ as well. Segment Trees have the notable benefit of supporting more functions that summation, though -- sums, products, maximum, minimum, GCD, LCM, as some examples.

The cost of this is some slight overhead -- there is more code to them than Fenwick Trees, and they require some additional memory as well, but generally most problems that can be solved with Fenwick Trees can also be solved with Segment Trees.

\subsubsection{Wavelet Tree}
\subsection{Ropes}
