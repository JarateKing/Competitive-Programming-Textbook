\section{Problem Analysis}
\subsection{IO Formats}

For the vast majority of problems, the IO is some variant on "here is the inputs for one or more testcases, for each testcase print the proper output".

At its simplest form, it will be the inputs for a single testcase.

\IOsample{code/io_formats/single_case}

Often, there will be multiple testcases, given by a number $t$.

\IOsample{code/io_formats/t_cases}

Other times, multiple testcases continue until you read a 0. For example:

\IOsample{code/io_formats/0_terminated}

Or instead will be terminated by no more input at all:

\IOsample{code/io_formats/null_terminated}

\subsubsection{Interactive IO}

There are some problems where you don't have all the input initially, and instead your solution communicates back and forth with the judge. These problems are called 'interactive problems' and are relatively uncommon but can throw someone off when they haven't encountered one before.

Consider a simple interactive problem, where we have to guess a number from 1 to 10. When we output our guess, we will get back a response that's either "correct" or "wrong". Then, if it's "wrong", we guess again. Usually there will be some limit on the number of guesses (often called queries) we can make, and in this problem we can limit the total number of guesses to be 10 (we should never need more than that, even for a very naive approach).

A naive solution can be:

\inputcpp{code/io_formats/interactive.cpp}

Note that we use \mintinline{c++}{std::endl} rather than \mintinline{c++}{'\n'} for our endlines. This is because \mintinline{c++}{'\n'} doesn't immediately print our outputs and will instead buffer them to print later (and is faster for that reason) which doesn't work in interactive problems.

This problem is not very representative of actual interactive problems, because it's so basic and you don't need to do any interesting logic based off of the interactivity (it's a simple loop . This is meant more as a "hello world" problem for interactive problems.

\subsection{Problem Solving}

Problem solving is not a well defined, simple to follow process. There is no algorithm to follow that will solve problems with success. Problem solving involves creativity and intuition. Competitive programming problems especially, where they are carefully designed with the intention of being interesting problems that usually require a creative solution.

That said, there is a general process that can make it easier to figure out a problem. This is not strictly defined, and serves as a rough method that can help.

\begin{enumerate}
\item Read the problem. It can sometimes be easier to read the inputs, outputs, and samples first and then going back to read the full description so you can understand the description in context of the exact problem.
\item Solve the sample cases on your own. Don't dwell on this if one of the samples is especially gnarly, but try to figure out how the problem is actually solved. As you go, try to keep note of any assumptions you make that are used in solving it, or could be used to make it easier to solve.
\item Identify the problem type. Is the problem a brute-force problem? Maybe it's a simulation problem, where you have to implement what it asks for and find the solution that way. Perhaps the solution requires a relatively advanced technique, and that technique is the problem type. Maybe there is no technique, and the solution requires some creative thinking without being tied to any common type (an "ad hoc" problem).

This is usually the hardest step, and the only way to get better at it is through practicing those problem types. The more problems of a specific type you solve, the better you will be at identifying it in a new problem you haven't seen before.
\item Consider counter-cases, if possible. The assumptions you made when solving the sample problems is what you used to determine the problem type. Do the samples handle all relevant cases, or are there cases you have to consider that aeen't given? Are your assumptions correct, or is there an error with your logic that means it requires an entirely different technique?
\end{enumerate}

These steps are usually done, to some degree, in parallel. You'll usually be thinking of the problem type when reading the problem and solving the samples, and you'll usually be thinking of potential counter-cases when determining the problem type. It is very common that you will redo these steps as well, because of things you didn't consider initially or figured out later. In practice, these are more things to keep in mind than a strict step-by-step process.

It's recommended to experiment with this on your own, both to familiarize yourself with it in practice and to tune it for yourself. Are there other steps you perform better with? Perhaps you have your own order to approaching things. Often, you might approach an easy problem completely differently than a complex one, because you can recognize the necessary techniques fairly quickly.

\subsection{Reading Comprehension}
\subsection{Debugging}
