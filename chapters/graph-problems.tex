\section{Graph Problems}
\subsection{Concepts}
\subsubsection{Nodes and Edges}
\subsubsection{Representations}

There are multiple ways to represent graphs when we talk about actually implementing them in code.

\textbf{Edge lists} are likely the most simple representation of a graph, in which we have an array store each edge in the graph. Nodes are implicit by their value -- an edge is represented as a pair of integers $a$ and $b$ (possibly with additional information like weight) that defines a connection between the $a$th node and the $b$th node.

\inputcpp{code/graph/core_edge_list.cpp}

Unfortunately, edge lists are relative uncommon and aren't the ideal graph representation for the majority of graph algorithms. This is because one of the most common things we want to do with graph algorithms is operate on edges connected to a specific node. With edge lists, this is $O(n)$ -- we have to traverse through the entire list to find what edges are connected to a specific node. We can optimize this somewhat (sort the edge list so all nodes appear in order in $O(n log n)$, then binary search for a specific node in $O(log n)$, for example) but ultimately we can do better with other graph representations for most use cases.

\textbf{Adjacency lists} are a graph representation in which we have an array of each node, where each node stores its edges. This fixes our issue with edge lists, because now we can index directly into a node and operate directly on all of its incident edges. This can either be as an array of \mintinline{cpp}{Node} objects where each \mintinline{cpp}{Node} contains an edge list, or as an array of edge lists. Even simpler, we can have an array where each index is the start node of the edge, and store a list of end node values:

\inputcpp{code/graph/core_adjacency_list.cpp}

Now, we may notice that we improved our accesses for our start node from $O(n)$ to $O(1)$ by using an array instead of a list, with the index equal to the start node of a given edge. Unfortunately, since adjacency lists still use lists, trying determine whether an edge between a specific start node and a specific end node exists is potentially expensive as well -- we would have to iterate through every edge indicent with the start node to find if that specific end node exists. So you may ask, why not use an array again, so that we have a 2D array where end nodes are our index for the inner array?

As it turns out, this is called an \textbf{adjacency matrix}. We maintain a 2D array of boolean values, so that we can quickly check whether an edge between $a$ and $b$ exists by checking the value of \mintinline{cpp}{edges[a][b]}.

\inputcpp{code/graph/core_adjacency_matrix.cpp}



\subsubsection{Directed and Undirected}
\subsubsection{Cyclic and Acyclic}
\subsubsection{Connected and Disconnected}
\subsubsection{Weighted}
\subsubsection{Transitive Closure}
\subsubsection{Grids}
\subsection{Pathfinding}

One of the most common tasks with graphs is to find a path between two nodes, or the distance between them. As we will see, traversing the graph in this manner is a common subtask in several other, more complicated graph algorithms as well.

It's important to know that, in general, there isn't any single pathfinding algorithm that you should always use. Each have their own strengths and weaknesses that are only relevant in certain circumstances, or come with specific restrictions that make them only worthwhile on specific types of graphs.

\subsubsection{Depth First Search}
\subsubsection{Breadth First Search}
\subsubsection{Djikstra's Algorithm}
\subsubsection{A* Algorithm}
\subsubsection{Bellman-Ford Algorithm}
\subsubsection{Floyd-Warshall Algorithm}
\subsection{Union-Find}

Union-Find, which also goes by the name of \textit{disjoint-set}, is a data structure that groups connected nodes together into different subsets through operations called \textbf{union} (which connects two nodes together, akin to creating an edge) and \textbf{find} (which determines which subset a node belongs to).

\subsection{Minimum Spanning Trees}

Many graphs have redundant edges -- between nodes $A$ and $B$ there may be several different paths. A spanning tree of a connected graph is one in which we use a subset of edges (whether we think of it as removing redundant edges or building up only the necessary edges depends on the algorithm we use) so that every pair of nodes has exactly one unique path between them.

A minimum spanning tree is a variant of a general spanning tree, where we want to obtain the minimum total weight among all spanning trees.

\subsubsection{Prim's Algorithm}
\subsubsection{Kruskal's Algorithm}
\subsection{Strongly Connected Components}
\subsubsection{Kosaraju's Algorithm}
\subsubsection{Tarjan's Algorithm}
\subsection{Maximum Flow}
\subsection{Bipartite Graphs}
\subsubsection{Determining Bipartite Graphs}
\subsubsection{Maximum Bipartite Matching}
\subsection{Eulerian Paths}

A Eulerian Path is a traversal of a graph in which every edge is visited exactly once. By consequence each node will also be visited one or more times.

Similarly, a Eulerian Cycle is a traversal of a graph that visits every edge exactly once with the added restriction that it's a cycle and has the same start and end node.

It is relatively easy to verify whether or not a Eulerian Path or Cycle exists. The following conditions must be satisfied:
\begin{itemize}
\item The graph must be connected
\item The degree of each node must be even
\end{itemize}

\subsubsection{BEST Algorithm}
\subsubsection{Hierholzer's Algorithm}
\subsection{Hamiltonian Paths}

A Hamiltonian Path is similar to a Eulerian Path except that it deals with nodes rather than edges -- it's a traversal in which each node is visited exactly once, and by consequence each edge is either visited once or not visited at all.

A Hamiltonian Cycle follows the same convention where we add the restriction that the end node of our traversal also has to be our source node.

Unlike Eulerian Paths and Cycles, verifying whether a Hamiltonian Path or Cycle exists or not is an NP-complete problem for the general case. There are special cases however:
\begin{itemize}
\item a complete graph with $n$ nodes has $(n-1)!/2$ different Hamiltonian Cycles.
\item By Dirac's Theorem, a simple graph with at least 3 nodes contains a Hamiltonian Cycle if every node has a degree of at least $\frac{n}{2}$ where $n$ is the number of nodes in the graph.
\item By Ore's Theorem (which generalizes Dirac's Theorem), a simple graph with at least 3 nodes contains a Hamiltonian Cycle if, for every pair of nodes in the graph, the sum of their degrees is at least $n$ where $n$ is the number of nodes in the graph.
\end{itemize}