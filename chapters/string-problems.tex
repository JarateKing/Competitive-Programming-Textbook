\section{String Problems}
\subsection{String Concepts}

\subsubsection{Anagrams}

Anagrams are the string equivalent to a permutation of an array. Two strings are anagrams of eachother if they contain the same elements, but their ordering isn't necessarily the same. For example, "abc" and "bac" are anagrams. Similarly, all anagrams of "abc" are \{"abc","acb","bac","bca","cab","cba"\}.

We can check whether two strings are anagrams by comparing the count of each character they have in their string:

\inputcpp{code/string/is_anagram_2.cpp}

That said, we can make our code smaller (though somewhat less efficient) by simply sorting the strings (so that they are both the lexicographically lowest anagram) and then comparing them.

\inputcpp{code/string/is_anagram_1.cpp}

\subsubsection{Lexicographic Order}

Lexicographic order of strings is one where strings are sorted based on the alphabetical ordering of their first characters. When strings have the same first character, the alphabetical order of their second characters are considered, and so on. A similar tie-breaker has to appear with shorter strings, where the end of the string is considered first alphabetically.

For example, \{"abc", "abd", "ada", "ae", "aeiou", "b"\} is a lexicographically ordered array of strings, following the rules above.

\subsubsection{Palindromes}

Palindromes are strings that are the same when they're reversed. For example, "abccba" or "abcba" are both palindromes, whereas "abcde" isn't.

It can be pretty easy to check if a string is a palindrome or not. We can simply check whether the first half of characters are equal to the second half of characters.

\inputcpp{code/string/is_palindrome.cpp}

\subsubsection{Prefixes}

Prefixes are substrings that contain the start of a string. For example, the prefixes of "abcde" are \{"a","ab","abc","abcd","abcde"\}.

\subsubsection{Suffixes}

Opposite to prefixes, suffixes are substrings that contain the end of a string. For example, the suffixes of "abcde" are \{"e","de","cde","bcde","abcde"\}.

\subsection{Pattern Matching}

One of the common tasks needed for string problems involves pattern matching -- determining whether or not a substring exists in the larger string altogether.

There are a fair amount of possible variants and alternatives to pattern matching. The simplest is simply "does a given substring exist in a given larger string" with no other complications.

\subsubsection{Regex}

Pattern matching can be solved easily using regular expressions. For example, consider in python:

\inputpython{code/string/regex.py}

The main advantages of regex are that they can be very quick to code, and they can support more advanced patterns. For example, if you wanted to match either "Hello" or "World", you could use \mintinline{python}{"(Hello)|(World)"} as the pattern. You could search for any consecutive pair of vowels with \mintinline{python}{"[aeiou]{2}"}, or any word that ends in s with \mintinline{python}{"\b.+s\b"}. Regex can define fairly complex patterns to search for in only one short line.

This comes with some hefty downsides though: namely that regex matching is significantly slower than other methods of pattern matching, that it requires an entire different syntax to write and is generally hard to understand once written, and that if the regex engine doesn't do exactly what you like it can't be easily modified to work.

\subsubsection{Knuth-Morris-Pratt}
\subsubsection{Boyer Moore}
\subsubsection{Z-Algorithm}
\subsubsection{Aho Corasick}
\subsection{Subsequence Matching}
\subsection{Hashing}
\subsection{Distance}
\subsubsection{Diff}
\subsubsection{Levenshtein}