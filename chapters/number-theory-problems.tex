\section{Number Theory Problems}

\subsection{Binary Exponentiation}

Consider the naive way to calculate $a^n$, we simply get the product of $n$ $a$s. In terms of code, we can simply initialize a variable to $1$ and then have a for-loop that multiplies our variable by $a$ a total of $n$ times. This works fine for $0^n$ where our answer should be 0, and $a^0$ where our answer should be $1$, but doesn't work for $0^0$ which is undefined (for simplicity's sake, we'll ignore $0^0$).

\inputcpp{code/number_theory/pow_naive.cpp}

\subsection{Primes}

\subsubsection{Prime Sieve}

\subsubsection{Primality Test}

\subsubsection{Prime Factoring}

\subsection{Greatest Common Divisor}

\subsubsection{Basic GCD}

\subsubsection{Extended GCD}

\subsubsection{Primal Representation}

Given a prime factorization of two numbers, the GCD is the product of factors in common. For example, the prime factorization of $60$ is $\{2,2,3,5\}$ while the prime factorization of $24$ is $\{2,2,2,3\}$. The factors in common are $\{2,2,3\}$ whose product is 12, which is the GCD of 60 and 24.

\subsubsection{Least Common Multiple}

The least common multiple between two non-zero integers can be calculated quickly: $\frac{a * b}{gcd(a, b)}$. Since $gcd(a, b)$ is a divisor of both $a$ and $b$ (and by extension $a * b$) this will always be an integer as well.

The primal representation of the LCM is similar to the primal representation of their GCD, except it's the product of factors they don't share multiplied by the product of factors in common (or GCD). For example, with $60$ and $24$ again, we have $\{2,5\}$ as unshared factors, along with $\{2,2,3\}$ as common factors, which is $2 * 2 * 2 * 3 * 5 = 120$ which is the LCM.

\subsubsection{Coprime Numbers}

Numbers are considered coprime (or relatively prime) if their GCD is 1. That is to say, they have no prime factors in common.

Prime numbers are, by necessity, coprime to other primes. This is because they would share no prime factors (for both, their sole prime factor being themselves) and as such have a GCD of 1. Following similar logic, any number is either coprime to a prime, or it's a multiple of that prime (because the only scenario that the GCD wouldn't be 1 is when the prime is a factor).

\subsection{Modular Arithmetic}

\subsubsection{Addition}

Addition can be fairly simple -- we add our numbers together and then perform the modulo operation on it. For example:

\inputcpp{code/number_theory/modulo_add.cpp}

The modulo operation is relatively expensive for a basic arithmetic operation, however. If we can guarantee that $a$ and $b$ are both less than $m$, we can avoid doing any modulo operations with:

\inputcpp{code/number_theory/modulo_add_fast.cpp}

\subsubsection{Subtraction}

Subtraction is similar to addition, but we need to guarantee that we don't go negative. We can fix this by simply adding $m$ before performing our modulo operation:

\inputcpp{code/number_theory/modulo_sub.cpp}

Likewise with addition, we can also optimize our subtraction function to not perform any modulo operation:

\inputcpp{code/number_theory/modulo_sub_fast.cpp}

\subsubsection{Multiplication}

Multiplication can (mostly) be performed similar to the non-optimized method of addition and subtraction -- by simply doing the multiplication operation and then performing the modulo operation on that. However, we may be concerned with overflows.

Specifically, consider $m = 10^9 + 7$. The largest numbers we will multiply will be when both $a$ and $b$ are equal to $10^9 + 6$. $a * b$ is somewhat above $10^{18}$ which is outside of the range of what a 32-bit integer can hold. In a language like C++ or Java, we will have to ensure that we use 64-bit integers when performing our multiplication:

\inputcpp{code/number_theory/modulo_mul.cpp}

\subsubsection{Exponentiation}

\subsubsection{Division (Prime Modulo)}

\subsubsection{Modular Inverse}

\subsubsection{Division (Any Modulo)}

\subsubsection{Discrete Log}

\subsubsection{Square Root}
