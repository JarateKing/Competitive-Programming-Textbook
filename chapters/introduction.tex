\section{Introduction}
\subsection{Recreational Programming}

Programming can be very productive -- making something with practical value, that people can use in their life to simplify tasks. Programming can also be done for the sake of programming itself, and only because it's fun. The latter is called "recreational programming", where the act of programming is done for fun rather than to create something useful.

There is a wide variety of forms of programming that people do recreationally. Many of them involve playing with how the sourcecode of a program appears, such as:
\begin{itemize}
\item Codegolf -- solving problems in as few characters of sourcecode as possible.
\item Polyglot Programming -- writing programs where the same sourcecode can successfully run in multiple different languages (either by giving the same output, or intentionally giving different outputs depending on the language).
\item Quine Programming -- programs that output their own sourcecode.
\item Obfuscation -- programs made to be as difficult to read as possible, and are very hard to understand what they do by looking at the sourcecode (see IOCCC).
\item Competitive Programming - solving well-defined problems under specific constraints (runtime, memory) often in a tournament setting with an emphasis on solving quickly.
\end{itemize}

This book focuses on competitive programming. It should stand out as the one most similar to raw problem solving -- in fact the only things it adds on top of basic problem solving is well-defined constraints. This makes it very useful in general programming, which is also essentially problem solving.

To some, competitive programming is very focused on the \textit{competitive} aspect. They will practice for the sake of getting better results than others. For others, the \textit{programming} part of competitive programming is what they focus on. They will practice for the sake of improving their own abilities. For many, it will be some mixture of both. In any case, both groups of people should find competitive programming fun in general.

\subsection{Competitive Programming}

The concept behind competitive programming is simple: you are given a problem with specific inputs and required outputs, and you have to submit code that solves it under well-defined constraints. These constraints are almost always in the form of a runtime limit and a memory limit. These are tested by an external "judge" that verifies your program works on hidden testcases (so that you can't hardcode the solution for every testcase) and that it works under the constraints (the runtime would depend on the computer that the judge is running on, but it should be relatively consistent for everyone submitting so no one gets an advantage or disadvantage).

There are several skills tested in competitive programming. Often, they rely on knowledge and creative applications of algorithms. Other times the solution does not need any particularly advanced techniques or prior knowledge, but tests your problem solving skills in an interesting way. Many times, it's easy to come up with a valid solution that, given enough time and memory, will get you the proper answer -- but the time constraints mean you need to develop a much more efficient approach to the problem. Some have a strong basis in math, while others are solely determined by computer science, and many combine mathematical and computational aspects together.

All of the above problem types take time to improve at. Sometimes they will be problems you are familiar with in your education and you can comfortably solve them, sometimes they will be advanced applications of techniques you've learned that are significantly more difficult than what you've likely encountered before, and sometimes they will involve techniques most people would never hear of outside of competitive programming.

\subsection{Value of Competitive Programming}

Competitive programming is very helpful to a programmer. For students, many homework tasks will be of a similar style to competitive programming tasks, and being skilled with competitive programming will give you a huge advantage in this sort of work. For those interested in academia, competitive programming is a great way to apply various algorithmic or computational techniques and to explore a wide variety of interesting problems to research. And for those looking to get hired by a company, not only does competitive programming experience look good on a resume, but many technical interviews involving algorithmic problems are essentially competitive programming problems. Someone with experience in competitive programming will have significant experience in all of the above that can be difficult to practice otherwise.

Not to mention that practicing competitive programming is a great way to practice programming in general. When learning a new language, it is useful to solve many smaller problems with it to get more comfortable. Fortunately, competitive programming practice involves many small problems to solve. When learning a new technique or algorithm, it's useful to find many problems that require it of varying difficulty. Often, competitive programming practice will list out problems in terms of topic and difficulty for this reason.

All that said, it's important to preface this book by saying that competitive programming won't help all your skills programming. Competitive programming tasks are a niche within programming, and as a result have special considerations. The biggest being that code maintainability doesn't matter at all for competitive programming, and as a consequence clean code practices can be pretty much entirely ignored (and often are, for the sake of typing faster) as long as you're still able to debug your solution in case of an error. Many practices recommended in competitive programming are actively discouraged in general software development, and vice versa. If you are looking to get better at writing readable and maintainable code, you have to be careful not to let competitive programming teach you bad habits.

Usually you don't care about things like memory management much either -- this is both a blessing and a cause for concern in a language like C++. It is generally much easier to learn and use C++ if you never deal with manual memory management, as long as the solution runs through the testcases without passing the memory limit. But it is also missing out on a major part of the language that you will need if you work on larger projects. Issues from badly management memory are a relatively rare problem in competitive programming (they happen all the time, but if your solution still gets accepted then it doesn't matter) but are a very frequent problem in general software development.

Don't let that dissuade you though. These sorts of things develop through practicing or working with larger projects, that you absolutely can do alongside competitive programming.

\subsection{Programming Contests}

There are a handful of prominent contests that regularly get held:

\begin{itemize}
\item ICPC (International Collegiate Programming Contest) is the main programming contest for university students.
\item IOI (International Olympiad in Informatics) is the main programming contest for highschool students.
\end{itemize}

\subsection{Programming Sites}

Outside of contests themselves, there are many sites that can be used for practice. A non-exhaustive list of several different competitive programming sites are:

\begin{itemize}
\item Kattis
\item Codeforces
\item Atcoder
\item Codechef
\item UVa
\end{itemize}

\subsection{Purpose of This Book}

The key purpose of this book is to familiarize students with many topics found in competitive programming.

There is a focus on beginner-level problems in this book that are ideal for learning a new programming language and growing proficiency in it. While this book doesn't detail the basics of a language or describe how to initially learn that language very much, it should serve as an excellent companion in practicing with that language and comparing it to other languages.

Specifically, the languages used in this book are Python, Java, and C++.

\subsection{Tips}

Before we begin really looking at competitive programming, it's important to go over some general tips.

\textbf{It's never too late} to begin competitive programming.

\textbf{It's never too early} to begin competitive programming either. Intentionally waiting until later to start programming competitively won't help you.

In other words, there's no better time to start than right now. There's a saying that goes "the best time to plant a tree was 20 years ago. The second best time is now." This applies to lots of things, but is true for competitive programming as well. As nice as it would be to have begun years ago, there's no sense procrastinating it now.

\textbf{Getting involved} is a great way to continue your competitive programming journey if you're involved with a community that focuses on it.

\textbf{Practicing consistently} is how you best grow your skills. Often people are extremely motivated to practice, go through lots of problems in a weekend or so, then get burnt out and don't touch another competitive programming problem for months. This is not a good way to practice -- it is far better to practice consistently and solve a small amount of problems regularly. Enough so that you learn new things often and can develop your skills, but not so much that you get mentally exhausted and can't keep it up for long.

\subsection{Example Problems}

We've discussed competitive programming a fair bit by this point, but haven't seen any actual problems yet. What does a competitive programming task look like? We'll cover a few here:

\hrulefill

\problem{Hello World!}
{When we begin programming, one of the first tasks we'll do is write out "Hello World!" or some variation. The same applies here -- likely the easiest competitive programming task you'll encounter is a simple "Hello World!" program. That's what we want in this program.}
{There is no Input}
{Output is a single string, Hello World!}
{1 second}
{1024 mb}
{\IOsample{problems/hello_world/1}}

\hrulefill

In the above problem we can notice several sections. We have the title of the problem, "Hello World!". Following this is a simple description. In this problem we have a pretty simple description.

After that, we have our input format. Hello world is a relatively unique problem in that it has no input -- these types of problems are rare. We do still have output, which we see in the next section, asking us to output "Hello World!". We also have our constraints section, where we list out the time limit and memory limit of our solutions. These constraints shouldn't be an issue for this problem specifically, but will come up in other problems.

We also have a sample input and output. When the program runs, it should produce the given output. These are basic test cases that are readily available to you.

\hrulefill

\problem{Apples and Oranges}
{Alice has many apples, and Owen has many oranges. The two of them usually get along, as long as Alice doesn't accidentally eat any oranges and Owen doesn't accidentally eat any apples.

As a friendly competition, Alice suggests that they compare how many of each fruit they have. Owen agrees, sure that he has more oranges than Alice has apples. Alice believes that she has more apples though. In true competition fashion, they get a judge to count so that they can be sure.

Unfortunately, while the judge knows how to count, they don't know how to tell what number is bigger than the other. It's up to you to help finish the contest and properly declare the winner.}
{You are given two integers, $a$ and $b$ where $0 \leq a,b \leq 10^9$. $a$ represents the number of apples that Alice has, and `b` represents the number of oranges that Owen has.}
{If Alice wins, print out "Alice". If Owen wins, print out "Owen". If it's a tie and neither wins, print out "Tie".}
{1 second}
{1024 mb}
{\IOsample{problems/apples_and_oranges/1}
\IOsample{problems/apples_and_oranges/2}
\IOsample{problems/apples_and_oranges/3}}

