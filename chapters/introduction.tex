\section{Introduction}
\subsection{Recreational Programming}

Programming can be very productive -- making something with practical value, that people can use in their life to simplify tasks. Programming can also be done for the sake of programming itself, and only because it's fun. The latter is called "recreational programming", where the act of programming is done for fun rather than to create something useful.

There is a wide variety of forms of programming that people do recreationally. Many of them involve playing with how the sourcecode of a program appears, such as:
\begin{itemize}
\item Codegolf -- solving problems in as few characters of sourcecode as possible.
\item Polyglot Programming -- writing programs where the same sourcecode can successfully run in multiple different languages (either by giving the same output, or intentionally giving different outputs depending on the language).
\item Quine Programming -- programs that output their own sourcecode.
\item Obfuscation -- programs made to be as difficult to read as possible, and are very hard to understand what they do by looking at the sourcecode (see IOCCC).
\item Competitive Programming - solving well-defined problems under specific constraints (runtime, memory) often in a tournament setting with an emphasis on solving quickly.
\end{itemize}

This book focuses on competitive programming. It should stand out as the one most similar to raw problem solving -- in fact the only things it adds on top of basic problem solving is well-defined constraints. This makes it very useful in general programming, which is also essentially problem solving.

To some, competitive programming is very focused on the \textit{competitive} aspect. They will practice for the sake of getting better results than others. For others, the \textit{programming} part of competitive programming is what they focus on. They will practice for the sake of improving their own abilities. For many, it will be some mixture of both. In any case, both groups of people should find competitive programming fun in general.

\subsection{Competitive Programming}

The concept behind competitive programming is simple: you are given a problem with specific inputs and required outputs, and you have to submit code that solves it under well-defined constraints. These constraints are almost always in the form of a runtime limit and a memory limit. These are tested by an external "judge" that verifies your program works on hidden testcases (so that you can't hardcode the solution for every testcase) and that it works under the constraints (the runtime would depend on the computer that the judge is running on, but it should be relatively consistent for everyone submitting so no one gets an advantage or disadvantage).

There are several skills tested in competitive programming. Often, they rely on knowledge and creative applications of algorithms. Other times the solution does not need any particularly advanced techniques or prior knowledge, but tests your problem solving skills in an interesting way. Many times, it's easy to come up with a valid solution that, given enough time and memory, will get you the proper answer -- but the time constraints mean you need to develop a much more efficient approach to the problem. Some have a strong basis in math, while others are solely determined by computer science, and many combine mathematical and computational aspects together.

All of the above problem types take time to improve at. Sometimes they will be problems you are familiar with in your education and you can comfortably solve them, sometimes they will be advanced applications of techniques you've learned that are significantly more difficult than what you've likely encountered before, and sometimes they will involve techniques most people would never hear of outside of competitive programming.

\subsection{Value of Competitive Programming}

Competitive programming is very helpful to a programmer. For students, many homework tasks will be of a similar style to competitive programming tasks, and being skilled with competitive programming will give you a huge advantage in this sort of work. For those interested in academia, competitive programming is a great way to apply various algorithmic or computational techniques and to explore a wide variety of interesting problems to research. And for those looking to get hired by a company, not only does competitive programming experience look good on a resume, but many technical interviews involving algorithmic problems are essentially competitive programming problems. Someone with experience in competitive programming will have significant experience in all of the above that can be difficult to practice otherwise.

Not to mention that practicing competitive programming is a great way to practice programming in general. When learning a new language, it is useful to solve many smaller problems with it to get more comfortable. Fortunately, competitive programming practice involves many small problems to solve. When learning a new technique or algorithm, it's useful to find many problems that require it of varying difficulty. Often, competitive programming practice will list out problems in terms of topic and difficulty for this reason.

All that said, it's important to preface this book by saying that competitive programming won't help all your skills programming. Competitive programming tasks are a niche within programming, and as a result have special considerations. The biggest being that code maintainability doesn't matter at all for competitive programming, and as a consequence clean code practices can be pretty much entirely ignored (and often are, for the sake of typing faster) as long as you're still able to debug your solution in case of an error. Many practices recommended in competitive programming are actively discouraged in general software development, and vice versa. If you are looking to get better at writing readable and maintainable code, you have to be careful not to let competitive programming teach you bad habits.

Usually you don't care about things like memory management much either -- this is both a blessing and a cause for concern in a language like C++. It is generally much easier to learn and use C++ if you never deal with manual memory management, as long as the solution runs through the testcases without passing the memory limit. But it is also missing out on a major part of the language that you will need if you work on larger projects. Issues from badly management memory are a relatively rare problem in competitive programming (they happen all the time, but if your solution still gets accepted then it doesn't matter) but are a very frequent problem in general software development.

Don't let that dissuade you though. These sorts of things develop through practicing or working with larger projects, that you absolutely can do alongside competitive programming.

\subsection{Programming Contests}

There are a handful of prominent contests that regularly get held:

\begin{itemize}
\item ICPC (International Collegiate Programming Contest) is the main programming contest for university students.
\item IOI (International Olympiad in Informatics) is the main programming contest for highschool students.
\end{itemize}

\subsection{Programming Sites}

Outside of contests themselves, there are many sites that can be used for practice. A non-exhaustive list of several different competitive programming sites are:

\begin{itemize}
\item Kattis
\item Codeforces
\item Atcoder
\item Codechef
\item UVa
\end{itemize}

\subsection{Purpose of This Book}

The key purpose of this book is to familiarize students with many topics found in competitive programming.

There is a focus on beginner-level problems in this book that are ideal for learning a new programming language and growing proficiency in it. While this book doesn't detail the basics of a language or describe how to initially learn that language very much, it should serve as an excellent companion in practicing with that language and comparing it to other languages.

Specifically, the languages used in this book are Python, Java, and C++.

\subsection{Tips}

Before we begin really looking at competitive programming, it's important to go over some general tips.

\textbf{It's never too late} to begin competitive programming.

\textbf{It's never too early} to begin competitive programming either. Intentionally waiting until later to start programming competitively won't help you.

In other words, there's no better time to start than right now. There's a saying that goes "the best time to plant a tree was 20 years ago. The second best time is now." This applies to lots of things, but is true for competitive programming as well. As nice as it would be to have begun years ago, there's no sense procrastinating it now.

\textbf{Getting involved} is a great way to continue your competitive programming journey if you're involved with a community that focuses on it.

\textbf{Practicing consistently} is how you best grow your skills. Often people are extremely motivated to practice, go through lots of problems in a weekend or so, then get burnt out and don't touch another competitive programming problem for months. This is not a good way to practice -- it is far better to practice consistently and solve a small amount of problems regularly. Enough so that you learn new things often and can develop your skills, but not so much that you get mentally exhausted and can't keep it up for long.

\textbf{Practice problems slightly above your level} rather than only practicing problems you find very easy (where you don't get much out of it) or problems that are very hard and far beyond your current level (where you don't get much out of it). You'll practice best doing problems outside of your comfort zone, but still doable for you. Solving easy problems can increase your typing speed and attempting hard problems can introduce you to new techniques, but in general you will develop your skills as a whole by practicing problems of a proper difficulty.

\textbf{Improve weak areas} so that you are more capable of solving problems of a certain type that you recognize you're not as strong at. It is far easier and faster to improve in a particular skill if you focus it specifically. If you're practicing a specific topic, you should prioritize the ones you're less comfortable with rather than the ones you're already proficient in. That isn't to say you should only work on specific topics -- trying whatever problems of a slightly higher difficulty than you can comfortably solve is good, but this tip is for if you intend to practice something specific rather than practice your general problem solving skills.

\subsection{Example Problems}

We've discussed competitive programming a fair bit by this point, but haven't seen any actual problems yet. What does a competitive programming task look like? We'll cover a few here.

After listing out some problems, we will go over the solutions for them and explain the problem itself. You've been warned in case you'd like to solve these problems on your own first (it is recommended).

\hrulefill

\input{problems/hello_world/description}

\hrulefill

In the above problem we can notice several sections. We have the title of the problem, \textbf{Hello World!}. Following this is a simple description. In this problem we have a pretty simple description.

After that, we have our input format. Hello world is a relatively unique problem in that it has no input -- these types of problems are rare. We do still have output, which we see in the next section, asking us to output "Hello World!". We also have our constraints section, where we list out the time limit and memory limit of our solutions. These constraints shouldn't be an issue for this problem specifically, but will come up in other problems.

We also have a sample input and output. When the program runs, it should produce the given output. These are basic test cases that are readily available to you.

\hrulefill

\input{problems/apples_and_oranges/description}

\hrulefill

This problem is slightly more involved than \textbf{Hello World!}. The actual problem itself isn't complicated, but there is now something inside the input section that we have to consider. For someone new to competitive programming or someone unfamiliar with math, this can be a bit intimidating. It simply means that you have two input numbers whose values are between 0 and $10^9$ (inclusive). It then describes what these numbers actually mean, where $a$ and $b$ are used in the rest of the problem.

The output section is also more involved than before. Our output depends on what we got for inputs. It is fairly easy to determine, but we do have to deal with 3 different cases for our output.

The samples section goes over a bit more detail too. Specifically, there are multiple samples to look at. For each given input, the program should output what is seen in the samples.

\hrulefill

\input{problems/factorial_digit_product/description}

\hrulefill

This problem is relatively difficult compared to the others. At first glance, we can notice that we have to handle multiple tests within a single testcase. This is not much more logic to handle, but does mean we have to be careful not to have too slow of a solution.

Without giving away the answer, runtime is likely something to be concerned for with this problem. The input section mentions that we can have up to $100000$ tests, where each number can be as large as $10^9$. We can assume that one of the hidden testcases will be something along the lines of requesting the factorial digit sum of $10^9$ $100000$ times. If we calculate the factorial naively, this will not be able to pass runtime constraints (not to mention that $10^9!$ is a huge number and multiplication slows down for larger numbers, and would require a custom class in C++ since it can't handle arbitrarily large numbers natively) -- we have to think of a smarter solution.

\hrulefill

The solutions to \textbf{Hello World!} look like:

\inputcpp{problems/hello_world/solution.cpp}
\inputjava{problems/hello_world/solution.java}
\inputpython{problems/hello_world/solution.py}

There is not much to say for the solution in general -- they look like you'd find from any other resource.

For C++ specifically, you can notice that we use \mintinline{cpp}{using namespace std;}. This just simplifies some of the rest of the program -- we can use \mintinline{cpp}{cout} instead of \mintinline{cpp}{std::cout}. This applies to nearly everything we obtain via \mintinline{cpp}{#include}. While there are arguments against using it in larger projects (namely, when you are dealing with many different namespaces that may or may not have conflicting function names) those same arguments don't apply too much to competitive programming (where you almost exclusively use the \mintinline{cpp}{std} namespace and programs only consist of a relatively small amount of functions) so you will find most people use \mintinline{cpp}{using namespace std;} when programming competitively.

It's not uncommon to see people also use \mintinline{cpp}{#include <bits/stdc++.h>} as our include statement instead of \mintinline{cpp}{#include <iostream>}. That is a technique specific to GCC compilers that imports everything in the standard library, so that you don't need to have multiple \mintinline{cpp}{#include}s for each different library used. We avoid doing so in this book, both because it makes the origin of certain standard library functions or classes more clear to not, and also to maintain compatibility with other compilers other than GCC (which does not apply when competitively programming, it only needs to work for whichever compiler you're using).

The solutions to \textbf{Apples and Oranges} look like:

\inputcpp{problems/apples_and_oranges/solution.cpp}
\inputpython{problems/apples_and_oranges/solution.py}

The solutions to \textbf{Factorial Digit Product} look like:

\inputcpp{problems/factorial_digit_product/solution.cpp}

You will notice that the solution is quite simple, and not necessarily immediately obvious. The problem description gives no indication that numbers above 4 are trivial to calculate. The fact that $5! = 120$ whose digit product is $0$, and that increasing the factorial and multiplying it more will always leave a $0$ as the last digit ($6! = 720$, $7! = 5040$, $8! = 40320$, $9! = 362880$, $10! = 3628800$ and so on) which means the digit product is always $0$ is an observation that needs to be made by the problem solver.

Because of this, we just have to have special cases for each number from $0$ to $4$ that we can figure out on paper easily (in fact the sample data already gives us the answer to all of these), and then print out $0$ if it's any other number.

---

This book will recommend other problems as well, related to the techniques explored in the chapter or subsection.

\begin{enumerate}
\item \url{https://open.kattis.com/problems/hello}
\item \url{https://open.kattis.com/problems/quadrant}
\item \url{https://open.kattis.com/problems/timeloop}
\item \url{https://open.kattis.com/problems/fizzbuzz}
\item \url{https://open.kattis.com/problems/lastfactorialdigit}
\end{enumerate}
